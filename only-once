#!/bin/bash

set -euo pipefail
. /.functions

[ -v WRAPPED_STATE ] || fail "Must set the WRAPPED_STATE environment variable to point to the location where to track if the initializer script has already been run"

require_dir_readwrite "${WRAPPED_STATE}"

[ -v WRAPPED_SCRIPT ] || fail "Must set the WRAPPED_SCRIPT environment variable to point to the script to be wrapped"
require_file_executable "${WRAPPED_SCRIPT}"

# In case the arguments haven't been defined
[ -v WRAPPED_SCRIPT_ARGS ] || WRAPPED_SCRIPT_ARGS=""

# If we're not given an explicit name to track state with, we deduce it from the script's
# filename and add a dot in front to hide the file
set_or_default WRAPPED_STATE_NAME ".${WRAPPED_SCRIPT##*/}"

MARKER="${WRAPPED_STATE}/${WRAPPED_STATE_NAME}"
[ -e "${MARKER}" ] && quit "The state has already been initialized"

init_ssl

running "Calling the wrapped script"
(
	# This should help mitigate exploitation
	eval CMD=( "${WRAPPED_SCRIPT@Q}" ${WRAPPED_SCRIPT_ARGS} ) || fail "Failed to define the wrapped command using script [${WRAPPED_SCRIPT}] and args [${WRAPPED_SCRIPT_ARGS}]"
	execute "${CMD[@]}"
) || fail "Failed to execute the wrapped script (rc=${?})"

TS="$(timestamp)"
ok "Wrapped script succeeded, marking the state to [${MARKER}] (timestamp = ${TS})"
echo "${TS}" > "${MARKER}" || fail "Failed to create the state tracking marker"
exit 0
